#!/usr/bin/env perl

use 5.010;
use strict;
use warnings;
use Transposome;
use File::Path qw(make_path remove_tree);
use File::Basename;
use Getopt::Long;
use Pod::Usage;

=head1 NAME

transposome - Investigate the repeat strucuture of a genome through unassembled sequence reads.

=head1 VERSION

Version 0.08.4

=cut

our $VERSION = '0.08.4';
#$VERSION = eval $VERSION;

=head1 SYNOPSIS

    transposome --config transposome_config.yml

=cut 

my %opts;

GetOptions(\%opts,
	   'c|config=s' => \$opts{config},
	   'v|version'  => \$opts{version},
	   'h|help'     => \$opts{help},
	   'm|man'      => \$opts{man},
	   ) or pod2usage( "Try '$0 --man' for more information." );

# Get configuration using Transposome class
usage() and exit(0) if $opts{help};
pod2usage( -verbose => 2 ) if $opts{man};
say $VERSION and exit(0) if $opts{version};

if ( !$opts{config} ) {
    say "\nERROR: No arguments were given.\n";
    usage();
    exit(1);
}

my $trans_obj = Transposome->new( config => $opts{config} );

# Parse configuration
my $config = $trans_obj->get_configuration;

unless ( -d $config->{output_directory} ) {
    make_path( $config->{output_directory}, {verbose => 0, mode => 0771,} );
}

# Initialize log and timers
my ( $t0, $log ) = init_transposome( $config );

# Perform the all vs. all blast
my $blastdb = run_blast( $config );
die "Blast failed. Please check the input sequence file and logs and try again. Report this issue if it persists. Exiting."
    unless -s $blastdb;

# parse mglblast results to find best scoring pairwise matches
my ( $idx_file, $int_file, $hs_file ) = find_pairs( $config, $blastdb );

# Cluster sequences and analyze groupings
my ( $cls_dir_path, $singletons_file_path, $seqct, $cls_tot ) = make_clusters( $config, $idx_file, $int_file, $hs_file );

# Annotate clusters and generate whole-genome summary of results
annotate_clusters( $config, $cls_dir_path, $singletons_file_path, $seqct, $cls_tot );

# Log summary of results
log_interval( $t0, $log );

#
# Methods
# 
sub init_transposome {
    my ($config) = @_;

    load_classes('File::Spec', 'Log::Log4perl', 'Time::HiRes', 'POSIX');

    my $log_file = File::Spec->catfile($config->{output_directory}, $config->{run_log_file});
    my $conf = qq{
    log4perl.category.Transposome      = INFO, Logfile, Screen

    log4perl.appender.Logfile          = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = $log_file
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout
    log4perl.appender.Logfile.layout.ConversionPattern = %m%n

    log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
    log4perl.appender.Screen.stderr  = 1
    log4perl.appender.Screen.layout  = Log::Log4perl::Layout::SimpleLayout
    };
    Log::Log4perl::init( \$conf );

    my $log = Log::Log4perl::get_logger("Transposome");
    
    my $t0 = [Time::HiRes::gettimeofday()];
    my $ts = POSIX::strftime('%d-%m-%Y %H:%M:%S', localtime);
    $log->info("======== Transposome version: $VERSION (started at: $ts) ========");
    $log->info("Configuration - Log file for monitoring progress and errors: $config->{run_log_file}");
    $log->info("Configuration - Sequence file:                               $config->{sequence_file}");
    $log->info("Configuration - Sequence format:                      :      $config->{sequence_format}");
    $log->info("Configuration - Sequence number for each BLAST process:      $config->{sequence_num}");
    $log->info("Configuration - Number of CPUs per thread:                   $config->{cpu}");
    $log->info("Configuration - Number of threads:                           $config->{thread}");
    $log->info("Configuration - Output directory:                            $config->{output_directory}");
    $log->info("Configuration - In-memory analysis:                          $config->{in_memory}");
    $log->info("Configuration - Percent identity for matches:                $config->{percent_identity}");
    $log->info("Configuration - Fraction coverage for pairwise matches:      $config->{fraction_coverage}");
    $log->info("Configuration - Merge threshold for clusters:                $config->{merge_threshold}");
    $log->info("Configuration - Minimum cluster size for annotation:         $config->{cluster_size}");
    $log->info("Configuration - BLAST e-value threshold for annotation:      $config->{blast_evalue}"); 
    $log->info("Configuration - Repeat database for annotation:              $config->{repeat_database}");
    $log->info("Configuration - Log file for clustering/merging results:     $config->{cluster_log_file}");

    return ($t0, $log);
}

sub run_blast {
    my ($config) = @_;

    load_classes('Transposome::Run::Blast');

    my $blast = Transposome::Run::Blast->new( file      => $config->{sequence_file},
					      format    => $config->{sequence_format},
					      dir       => $config->{output_directory},
					      threads   => $config->{thread},
					      cpus      => $config->{cpu},
					      seq_num   => $config->{sequence_num} );
    
    my $blastdb = $blast->run_allvall_blast;

    return $blastdb;
}

sub find_pairs {
    my ($config, $blastdb) = @_;

    load_classes('Transposome::PairFinder');

    my $blast_res = Transposome::PairFinder->new( file              => $blastdb,  
						  dir               => $config->{output_directory},
						  in_memory         => $config->{in_memory},
						  percent_identity  => $config->{percent_identity},
						  alignment_length  => $config->{alignment_length} );
    
    my ($idx_file, $int_file, $hs_file) = $blast_res->parse_blast;

    unlink $blastdb;
    return ($idx_file, $int_file, $hs_file);
}

sub make_clusters {
    my ($config, $idx_file, $int_file, $hs_file) = @_;
    
    load_classes('Transposome::Cluster', 'Transposome::SeqUtil');

    my $cluster = Transposome::Cluster->new( file            => $int_file,
					     dir             => $config->{output_directory},
					     merge_threshold => $config->{merge_threshold},
					     cluster_size    => $config->{cluster_size} );
    
    my $comm = $cluster->louvain_method;
    my $cluster_file = $cluster->make_clusters($comm, $idx_file);
    my ($read_pairs, $vertex, $uf) = $cluster->find_pairs($cluster_file, $config->{cluster_log_file});
 
    my $memstore = Transposome::SeqUtil->new( file      => $config->{sequence_file}, 
					      in_memory => $config->{in_memory},
					      format    => $config->{sequence_format} );

    my ($seqs, $seqct) = $memstore->store_seq;

    my ($cls_dir_path, $cls_with_merges_path, $singletons_file_path, $cls_tot) 
        = $cluster->merge_clusters($vertex, $seqs, $read_pairs, $config->{cluster_log_file}, $uf);


    unlink $idx_file, $int_file, $hs_file;
    return ($cls_dir_path, $singletons_file_path, $seqct, $cls_tot);
}

sub annotate_clusters {
    my ($config, $cls_dir_path, $singletons_file_path, $seqct, $cls_tot) = @_;
    
    load_classes('Transposome::Annotation', 'File::Find', 'Archive::Tar');

    my $annotation = Transposome::Annotation->new( database  => $config->{repeat_database},
						   dir       => $config->{output_directory},
						   file      => $config->{cluster_log_file},
						   threads   => $config->{thread},
						   cpus      => $config->{cpu} );

    my ($anno_rp_path, $anno_sum_rep_path, $singles_rp_path, $total_readct, $rep_frac, $blasts, $superfams)
	= $annotation->annotate_clusters($cls_dir_path, $singletons_file_path, $seqct, $cls_tot);

    $annotation->clusters_annotation_to_summary($anno_rp_path, $anno_sum_rep_path, $singles_rp_path, 
						$total_readct, $seqct, $rep_frac, $blasts, $superfams);

    my $anno_dir_path = $cls_dir_path."_annotations";
    my $outdir        = dirname($cls_dir_path);
    my $cls_tar_file  = basename($cls_dir_path);
    my $anno_tar_file = basename($anno_dir_path);
    my $cls_tar_path  = File::Spec->catfile($outdir, $cls_tar_file.".tgz");
    my $anno_tar_path = File::Spec->catfile($outdir, $anno_tar_file.".tgz");

    say join q{ }, "DEBUG: ", $cls_tar_path, $anno_tar_path;
    my (@clusters, @annotations);
    find( sub { push @clusters,    $File::Find::name }, $cls_dir_path );
    find( sub { push @annotations, $File::Find::name }, $anno_dir_path );

    my $ctar = Archive::Tar->new;
    $ctar->add_files(@clusters);
    $ctar->write($cls_tar_path, &COMPRESS_GZIP);

    my $atar = Archive::Tar->new;
    $atar->add_files(@annotations);
    $atar->write($anno_tar_path, &COMPRESS_GZIP);

    remove_tree( $cls_dir_path,  { safe => 1 } );
    remove_tree( $anno_dir_path, { safe => 1 } );
}

sub log_interval {
    my ($t0, $log) = @_;
    
    load_classes('DateTime', 'Time::HiRes', 'Lingua::EN::Inflect', 'POSIX');

    my $t1    = [Time::HiRes::gettimeofday()];
    my $t0_t1 = Time::HiRes::tv_interval($t0, $t1);
    my $dt    = DateTime->from_epoch( epoch => 0 );

    $dt = $dt->add( seconds => $t0_t1 );
    $dt = $dt - DateTime->from_epoch( epoch => 0 );
    
    my @time;
    push @time, $dt->days . Lingua::EN::Inflect::PL_N( ' day', $dt->days ) if $dt->days;
    push @time, $dt->hours . Lingua::EN::Inflect::PL_N( ' hour', $dt->hours ) if $dt->hours;
    push @time, $dt->minutes . Lingua::EN::Inflect::PL_N( ' minute', $dt->minutes ) if $dt->minutes;
    push @time, $dt->seconds . Lingua::EN::Inflect::PL_N( ' second', $dt->seconds ) if $dt->seconds;
    my $timestr = join ', ', @time;
    
    my $fs = POSIX::strftime('%d-%m-%Y %H:%M:%S', localtime);
    $log->info("======== Transposome completed at: $fs. Elapsed time: $timestr. ========");
}

sub load_classes {
    my @classes = @_;

    for my $class (@classes) {
        eval {
            eval "require $class";
            $class->import();
            1;
        } or do {
            my $error = $@;
            die "\nERROR: The module $class is required but it couldn't be loaded. ".
                "Here is the exception: $error." if $error;
        };
    }
}

sub usage {
    my $prog = basename($0);
    print STDERR <<END
USAGE: $prog [-c] [-v] [-h] [-m]

Required:
    -c|config  :    The Transposome configuration file.

Options:
    -v|version :    Print the program version and exit.
    -h|help    :    Print a usage statement.
    -m|man     :    Print the full documentation.

END
}

=head1 REQUIRED ARGUMENTS

=over 2

=item -c, --config

The Transposome configuration file.

=back 

=head1 OPTIONS

=over 2

=item -v, --version

Print the Transposome version and exit.

=item -h, --help

Print a usage statement. 

=item -m, --man

Print the full documentation.

=back

=head1 AUTHOR

S. Evan Staton, C<< <statonse at gmail.com> >>

=head1 BUGS

Please report any bugs or feature requests through the project site at 
L<https://github.com/sestaton/Transposome/issues>. I will be notified,
and there will be a record of the issue. Alternatively, I can also be 
reached at the email address listed above to resolve any questions.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc transposome


=head1 LICENSE AND COPYRIGHT

Copyright 2013-2015 S. Evan Staton.

This program is distributed under the MIT (X11) License:
L<http://www.opensource.org/licenses/mit-license.php>

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.


=cut
